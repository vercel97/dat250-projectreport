\clearpage
\section{Prototype Implementation}
\label{sec:implementation}

\subsection{Frontend}
The following components have been implemented for the front end:

\begin{itemize}
	\item Login: this is the first view that the user are presented with. It’s main purpose is to
authenticate users, and help them access the application. It contains input fields for
username and password. When the user presses “Log in”, he is taken to the main-page of the
application. If the user is not registered, he can easily do so by pressing the “Register”-
button.
	\item Register: here the user is presented a schema, where he can register and that way access the
application. He needs to add an email address, a username and a password. Once the
information is submitted, the user is sent back to the login page.
	\item Main-page: This component contains buttons that lets the user easily navigate to all parts of
the application quickly.
	\item Find-poll: Here the user can search for a poll via its id, or by a poll-name. All the polls that
matches the input will then be displayed with the option to vote on it.
	\item Create-poll: Here the user can create a new poll. He can decide the questions that should be
displayed, when the poll is active, if it is private and invite users to participate in it. Once
created, a poll-id is given to the user. This can for example be given to other users and used
to search for the poll.
	\item Vote: Here the user gets to submit votes to active polls.
\end{itemize}

A authentication service, a poll service and a voting service has also been created to handle logic that
can be applied to multiple components. The authentication service handles operations such as
logging the user in to the application and searching for users. The poll service handles logic depicting
the polls such as finding polls, creating polls and changing polls. The Voting service handles the logic
connected to the voting.

The following subsection describes more detailed how the logic behind the authentification process has been implemented, 
and displays how the frontend is connected to the REST API. 

\subsubsection{Authentication Process}
A crucial part of the frontend implementation is the user authentication process. 
This is managed through the \texttt{login} method in the \texttt{auth.service} file and the \texttt{onSubmit} method in the \texttt{LoginComponent}.

The \texttt{login} method is defined as:
\begin{verbatim}
login(user: { username: string, password: string }) {
  return this.http.post<string>(`${this.apiUrl}/login`, user, {
    headers: new HttpHeaders({ 'Content-Type': 'application/json' }),
    responseType: 'text' as 'json'
  }).pipe(
    tap(response => {
      localStorage.setItem('authToken', response);
      localStorage.setItem('username', user.username);
      console.log('Server response:', response);
    })
  );
}
\end{verbatim}

This method handles user login credentials, sending them to the backend for verification and storing the received token and 
username in the browser's local storage for session management. The token is stored in the local storage to maintain the user sessions. 

The \texttt{LoginComponent} uses this service in its \texttt{onSubmit} method:
\begin{verbatim}
onSubmit() {
  if (this.loginForm.valid) {
    this.authService.login(this.loginForm.value)
      .subscribe(
        (token: string) => {
          if (token) {
            localStorage.setItem('authToken', token);
            this.router.navigate(['/main-page']);
          } else {
            alert('Incorrect username or password.');
          }
        },
        (error: any) => {
          if (error.status === 401) {
            alert('Incorrect username or password.');
          } else {
            alert('An error occurred during login.');
          }
        }
      );
  }
}
\end{verbatim}

This function makes sure that only users with valid credentials are able to access the main page of the application, while also handling 
different error scenarios. If a user gives an incorrect credential or any other login error occurs, an error message is displayed. 

\subsection{Backend}
The architecture of our program has modular architecture that includes multiple important entities and their corresponding repositories.

\subsubsection{Entities}
We will begin by describing the structural components of the application which is object-oriented by design. The primary class, \texttt{AppUser}, implements properties such as username, email, and password. It also holds a collection of polls owned by the AppUser.  A critical feature of this class is the implementation of two-factor authentication, validated through a verification code to ascertain user authenticity. \\

\noindent The \texttt{Poll} class, a core entity in our application, represents polls created by users. It includes details like title, open/close status, and duration, and can contain multiple questions. The poll implements general properties for storing privacy status, activity status, duration, and IoT device pairing. It also implements specific properties like the poll title, vote tallies, a list of authorized users (for private polls only) and funttion implementation to perform question management such as add, delete and edit. Polls are also linked to IoT device and therefore, holds information on which device it is paired with.\\

\noindent The \texttt{Question} class constitutes individual items within polls for users to vote on. Records responses and associates with specific polls.\\

\noindent A \texttt{Vote} class records user votes in polls, indicating 'yes' or 'no' choices. It contains the logic that is responsble for determining which question in a poll the vote should be submitted towards.\\

\noindent The \texttt{IoTDisplay} is a singleton class only aware of its associated IoT device by the property pariedDevice, which contains a string value of of the device name. \\

\noindent \texttt{ThirdPartyApp} interface class provides logic to allow third party entties to retreive data from the application. \\


\subsubsection{Repositories}
\begin{itemize}
    \item \textbf{AppUserRepository}: Manages \texttt{AppUser} data operations, including user lookup by username.
    \item \textbf{PollRepository}: Handles data operations for \texttt{Poll}, with custom queries for poll title searches.
    \item \textbf{QuestionRepository}: Provides data access for \texttt{Question}.
    \item \textbf{VoteRepository}: Manages \texttt{Vote} data, including vote counting in polls.
    \item \textbf{VoterRepository}: Dedicated to \texttt{Voter} entity operations.
\end{itemize}

\subsubsection{Integration with Spring Boot, Hibernate, and JPA}
Our voting application uses:

\begin{itemize}
    \item \textbf{Spring Boot} as a framework, simplifing configuration and setup.
    \item \textbf{Hibernate} as the ORM tool, translating Java objects to database representations.
    \item \textbf{JPA interfaces}, such as \texttt{JpaRepository}, for efficient data access and manipulation.
\end{itemize}

\subsubsection{Functionality}

Supported data models functionalities in our application:
\begin{itemize}
    \item User registration and management.
    \item Interactive poll creation and management.
    \item Voting mechanisms within polls.
    \item Integration with IoT devices for an enhanced user experience.
\end{itemize}

\subsection{REST API}
The web application consists of three key controllers, each handling different aspects of the voting system:

\begin{itemize}
    \item \textbf{AppUserController}: Manages user-related functionalities, such as user registration, authentication, and profile management.
    \item \textbf{PollController}: Focused on poll management, including creating, updating, and deleting polls, as well as opening and closing them, and publishing results.
    \item \textbf{QuestionController}: Handles operations related to individual questions within polls, including CRUD operations and specific voting mechanisms.
\end{itemize}

\subsubsection{RESTful Design}
All three controllers are designed following REST principles, offering a specific base URLs and using HTTP methods for standard CRUD operations.

\subsubsection{Spring Boot and Spring Data Integration}
They utilize Spring Boot's capabilities for creating standalone applications and Spring Data's repository pattern for data access. Dependency injection with \texttt{@Autowired} is also used.

\subsubsection{Error Handling and Response Management}
The controllers use \texttt{ResponseEntity} class for HTTP response handling, allowing them to manage different scenarios (even those ending with an error).

Method \texttt{deleteQuestion} in \texttt{QuestionController} that is responsible for deleting a question in a poll returns an error response if the question wasn't found:
\begin{verbatim}
  @DeleteMapping("/{id}")
  public ResponseEntity<Void> deleteQuestion(@PathVariable int id) {
      Optional<Question> question = questionRepository.findById(id);
      if (question.isPresent()) {
          questionRepository.delete(question.get());
          return ResponseEntity.ok().build();
      } else {
          return ResponseEntity.notFound().build();
      }
  }
\end{verbatim}

\subsubsection{Unique Features}
\begin{itemize}
    \item \textbf{AppUserController}: Includes user authentication, registration, and verification processes.
    \item \textbf{PollController}: Manages poll result publication and status (open/close).
    \item \textbf{QuestionController}: Introduces a voting mechanism for questions, indicating interaction granularity.
\end{itemize}

\subsubsection{Security and User Management}
The \texttt{AppUserController} focuses on security and user identity management through authentication and JWT token management.

\hfill \break

There are also a few features that we modelled into our application in the first phase of this project,
but due to the time constraints are yet to be implemented. These include Poll management and User
management. Currently the application allows users to create and participate in polls. However, the
management of the polls is not yet functional. The same goes for the management of the user
settings. The buttons has been created in the main-page component, but they are not directing the
users to new views yet.